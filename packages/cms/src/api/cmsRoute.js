const {Client} = require("mondrian-rest-client");
const d3Array = require("d3-array");
const sequelize = require("sequelize");
const shell = require("shelljs");
const path = require("path");
const Op = sequelize.Op;

const client = new Client(process.env.CANON_LOGICLAYER_CUBE);

const topicTypeDir = path.join(__dirname, "../components/topics/");

const isAuthenticated = (req, res, next) => {
  if (process.env.NODE_ENV === "development") return next();
  return res.status(401).send("Not Authorized");
};

const profileReqTreeOnly = {
  attributes: ["id", "title", "slug", "dimension", "ordering"],
  include: [
    {
      association: "sections", attributes: ["id", "title", "slug", "ordering", "profile_id"],
      include: [
        {association: "topics", attributes: ["id", "title", "slug", "ordering", "section_id", "type"]}
      ]
    }
  ]
};

const storyReqTreeOnly = {
  attributes: ["id", "title", "ordering"],
  include: [
    {
      association: "storytopics", attributes: ["id", "title", "slug", "ordering", "story_id", "type"]
    }
  ]
};

const formatterReqTreeOnly = {
  attributes: ["id", "name"]
};

const profileReqProfileOnly = {
  include: [
    {association: "generators", attributes: ["id", "name"]},
    {association: "materializers", attributes: ["id", "name", "ordering"]},
    {association: "stats", attributes: ["id", "ordering"]},
    {association: "footnotes", attributes: ["id", "ordering"]}
  ]
};

const storyReqStoryOnly = {
  include: [
    {association: "authors", attributes: ["id", "ordering"]},
    {association: "descriptions", attributes: ["id", "ordering"]},
    {association: "footnotes", attributes: ["id", "ordering"]}
  ]
};

const sectionReqSectionOnly = {
  include: [
    {association: "subtitles", attributes: ["id", "ordering"]},
    {association: "descriptions", attributes: ["id", "ordering"]}
  ]
};

const topicReqTopicOnly = {
  include: [
    {association: "subtitles", attributes: ["id", "ordering"]},
    {association: "descriptions", attributes: ["id", "ordering"]},
    {association: "visualizations", attributes: ["id", "ordering"]},
    {association: "stats", attributes: ["id", "ordering"]},
    {association: "selectors"}
  ]
};

const storyTopicReqStoryTopicOnly = {
  include: [
    {association: "subtitles", attributes: ["id", "ordering"]},
    {association: "descriptions", attributes: ["id", "ordering"]},
    {association: "visualizations", attributes: ["id", "ordering"]},
    {association: "stats", attributes: ["id", "ordering"]}
  ]
};

/**
 * API paths are dynamically generated by folding over this list in the get/post methods that follow.
 * IMPORTANT: When new tables are added to the CMS, adding their exact tablename to this list will
 * automatically generate Create, Update, and Delete Routes (as specified later in the get/post methods)
 */
const cmsTables = [
  "author", "formatter", "generator", "materializer", "profile",
  "profile_footnote", "profile_stat", "section", "section_description",
  "section_subtitle", "selector", "story", "story_description", "story_footnote", "storytopic",
  "storytopic_description", "storytopic_stat", "storytopic_subtitle", "storytopic_visualization",
  "topic", "topic_description", "topic_stat", "topic_subtitle", "topic_visualization"
];

const sorter = (a, b) => a.ordering - b.ordering;

// Using nested ORDER BY in the massive includes is incredibly difficult so do it manually here. todo: move it up to the query.
const sortProfileTree = profiles => {
  profiles = profiles.map(p => p.toJSON());
  profiles.sort(sorter);
  profiles.forEach(p => {
    p.sections.sort(sorter);
    p.sections.forEach(s => {
      s.topics.sort(sorter);
    });
  });
  return profiles;
};

const sortStoryTree = stories => {
  stories = stories.map(s => s.toJSON());
  stories.sort(sorter);
  stories.forEach(s => {
    s.storytopics.sort(sorter);
  });
  return stories;
};

const sortProfile = profile => {
  profile = profile.toJSON();
  ["materializers", "stats", "footnotes"].forEach(type => profile[type].sort(sorter));
  return profile;
};

const sortStory = story => {
  story = story.toJSON();
  ["descriptions", "footnotes", "authors"].forEach(type => story[type].sort(sorter));
  return story;
};

const sortSection = section => {
  section = section.toJSON();
  ["subtitles", "descriptions"].forEach(type => section[type].sort(sorter));
  return section;
};

const sortTopic = topic => {
  topic = topic.toJSON();
  ["subtitles", "visualizations", "stats", "descriptions", "selectors"].forEach(type => topic[type].sort(sorter));
  return topic;
};

const sortStoryTopic = storytopic => {
  storytopic = storytopic.toJSON();
  ["subtitles", "visualizations", "stats", "descriptions"].forEach(type => storytopic[type].sort(sorter));
  return storytopic;
};

const formatter = (members, data, dimension, level) => {

  const newData = members.reduce((arr, d) => {
    const obj = {};
    obj.id = `${d.key}`;
    obj.name = d.name;
    obj.display = d.caption;
    obj.zvalue = data[obj.id] || 0;
    obj.dimension = dimension;
    obj.hierarchy = level;
    obj.stem = -1;
    arr.push(obj);
    return arr;
  }, []);
  const st = d3Array.deviation(newData, d => d.zvalue);
  const average = d3Array.median(newData, d => d.zvalue);
  newData.forEach(d => d.zvalue = (d.zvalue - average) / st);
  return newData;
};

const populateSearch = (profileData, db) => {

  /**
   *
   */
  async function start() {

    const cubeName = profileData.cubeName;
    const measure = profileData.measure;
    const dimension = profileData.dimName;
    const dimLevels = profileData.levels;

    const cube = await client.cube(cubeName);

    const levels = cube.dimensionsByName[dimension].hierarchies[0].levels
      .filter(l => l.name !== "(All)" && dimLevels.includes(l.name));

    let fullList = [];
    for (let i = 0; i < levels.length; i++) {

      const level = levels[i];
      const members = await client.members(level);

      const data = await client.query(cube.query
        .drilldown(dimension, level.hierarchy.name, level.name)
        .measure(measure), "jsonrecords")
        .then(resp => resp.data.data)
        .then(data => data.reduce((obj, d) => {
          obj[d[`ID ${level.name}`]] = d[measure];
          return obj;
        }, {}));

      fullList = fullList.concat(formatter(members, data, dimension, level.name));

    }

    for (let i = 0; i < fullList.length; i++) {
      const obj = fullList[i];
      const {id, dimension, hierarchy} = obj;
      const [row, created] = await db.search.findOrCreate({
        where: {id, dimension, hierarchy},
        defaults: obj
      });
      if (created) console.log(`Created: ${row.id} ${row.display}`);
      else {
        await row.updateAttributes(obj);
        console.log(`Updated: ${row.id} ${row.display}`);
      }
    }

  }

  start();

};

module.exports = function(app) {

  const {db} = app.settings;

  /* GETS */

  app.get("/api/cms/tree", (req, res) => {
    db.profile.findAll(profileReqTreeOnly).then(profiles => {
      profiles = sortProfileTree(profiles);
      res.json(profiles).end();
    });
  });

  app.get("/api/cms/storytree", (req, res) => {
    db.story.findAll(storyReqTreeOnly).then(stories => {
      stories = sortStoryTree(stories);
      res.json(stories).end();
    });
  });

  app.get("/api/cms/formattertree", (req, res) => {
    db.formatter.findAll(formatterReqTreeOnly).then(formatters => {
      res.json(formatters).end();
    });
  });

  app.get("/api/cms/profile/get/:id", (req, res) => {
    const {id} = req.params;
    const reqObj = Object.assign({}, profileReqProfileOnly, {where: {id}});
    db.profile.findOne(reqObj).then(profile => {
      res.json(sortProfile(profile)).end();
    });
  });

  app.get("/api/cms/story/get/:id", (req, res) => {
    const {id} = req.params;
    const reqObj = Object.assign({}, storyReqStoryOnly, {where: {id}});
    db.story.findOne(reqObj).then(story => {
      res.json(sortStory(story)).end();
    });
  });

  app.get("/api/cms/section/get/:id", (req, res) => {
    const {id} = req.params;
    const reqObj = Object.assign({}, sectionReqSectionOnly, {where: {id}});
    db.section.findOne(reqObj).then(section => {
      res.json(sortSection(section)).end();
    });
  });

  app.get("/api/cms/topic/get/:id", (req, res) => {
    const {id} = req.params;
    const reqObj = Object.assign({}, topicReqTopicOnly, {where: {id}});
    db.topic.findOne(reqObj).then(topic => {
      const topicTypes = [];
      shell.ls(`${topicTypeDir}*.jsx`).forEach(file => {
        const compName = file.replace(topicTypeDir, "").replace(".jsx", "");
        topicTypes.push(compName);
      });
      topic = sortTopic(topic);
      topic.types = topicTypes;
      res.json(topic).end();
    });
  });

  app.get("/api/cms/storytopic/get/:id", (req, res) => {
    const {id} = req.params;
    const reqObj = Object.assign({}, storyTopicReqStoryTopicOnly, {where: {id}});
    db.storytopic.findOne(reqObj).then(storytopic => {
      const topicTypes = [];
      shell.ls(`${topicTypeDir}*.jsx`).forEach(file => {
        const compName = file.replace(topicTypeDir, "").replace(".jsx", "");
        topicTypes.push(compName);
      });
      storytopic = sortStoryTopic(storytopic);
      storytopic.types = topicTypes;
      res.json(storytopic).end();
    });
  });

  // Top-level tables have their own special gets, so exclude them from the "simple" gets
  const getList = cmsTables.filter(tableName =>
    !["profile", "section", "topic", "story", "storytopic"].includes(tableName)
  );

  getList.forEach(ref => {
    app.get(`/api/cms/${ref}/get/:id`, (req, res) => {
      db[ref].findOne({where: {id: req.params.id}}).then(u => res.json(u).end());
    });
  });

  /* INSERTS */
  // For now, all "create" commands are identical, and don't need a filter (as gets do above), so we may use the whole list.
  const newList = cmsTables;
  newList.forEach(ref => {
    app.post(`/api/cms/${ref}/new`, isAuthenticated, (req, res) => {
      db[ref].create(req.body).then(u => res.json(u));
    });
  });

  app.post("/api/cms/profile/newScaffold", isAuthenticated, (req, res) => {
    const profileData = req.body;
    db.profile.create({slug: profileData.slug, ordering: profileData.ordering, dimension: profileData.dimName}).then(profile => {
      db.section.create({ordering: 0, profile_id: profile.id}).then(section => {
        db.topic.create({ordering: 0, section_id: section.id}).then(() => {
          db.profile.findAll(profileReqTreeOnly).then(profiles => {
            profiles = sortProfileTree(profiles);
            populateSearch(profileData, db);
            res.json(profiles).end();
          });
        });
      });
    });
  });

  /* UPDATES */
  // For now, all "update" commands are identical, and don't need a filter (as gets do above), so we may use the whole list.
  const updateList = cmsTables;
  updateList.forEach(ref => {
    app.post(`/api/cms/${ref}/update`, isAuthenticated, (req, res) => {
      db[ref].update(req.body, {where: {id: req.body.id}}).then(u => res.json(u));
    });
  });

  /* DELETES */
  /**
   * To streamline deletes, this list contains objects with two properties. "elements" refers to the tables to be modified,
   * and "parent" refers to the foreign key that need be referenced in the associated where clause.
   */
  const deleteList = [
    {elements: ["profile_footnote", "profile_stat"], parent: "profile_id"},
    {elements: ["section_description", "section_subtitle"], parent: "section_id"},
    {elements: ["author", "story_description", "story_footnote"], parent: "story_id"},
    {elements: ["topic_subtitle", "topic_description", "topic_stat", "topic_visualization"], parent: "topic_id"}
  ];

  deleteList.forEach(list => {
    list.elements.forEach(ref => {
      app.delete(`/api/cms/${ref}/delete`, isAuthenticated, (req, res) => {
        db[ref].findOne({where: {id: req.query.id}}).then(row => {
          // Construct a where clause that looks someting like: {profile_id: row.profile_id, ordering: {[Op.gt]: row.ordering}}
          // except "profile_id" is the "parent" in the array above
          const where1 = {ordering: {[Op.gt]: row.ordering}};
          where1[list.parent] = row[list.parent];
          db[ref].update({ordering: sequelize.literal("ordering -1")}, {where: where1}).then(() => {
            db[ref].destroy({where: {id: req.query.id}}).then(() => {
              const where2 = {};
              where2[list.parent] = row[list.parent];
              db[ref].findAll({where: where2, attributes: ["id", "ordering"], order: [["ordering", "ASC"]]}).then(rows => {
                res.json(rows).end();
              });
            });
          });
        });
      });
    });
  });

  // Other (More Complex) Elements
  app.delete("/api/cms/generator/delete", isAuthenticated, (req, res) => {
    db.generator.findOne({where: {id: req.query.id}}).then(row => {
      db.generator.destroy({where: {id: req.query.id}}).then(() => {
        db.generator.findAll({where: {profile_id: row.profile_id}, attributes: ["id", "name"]}).then(rows => {
          res.json(rows).end();
        });
      });
    });
  });

  app.delete("/api/cms/materializer/delete", isAuthenticated, (req, res) => {
    db.materializer.findOne({where: {id: req.query.id}}).then(row => {
      db.materializer.update({ordering: sequelize.literal("ordering -1")}, {where: {profile_id: row.profile_id, ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.materializer.destroy({where: {id: req.query.id}}).then(() => {
          db.materializer.findAll({where: {profile_id: row.profile_id}, attributes: ["id", "ordering", "name"], order: [["ordering", "ASC"]]}).then(rows => {
            res.json(rows).end();
          });
        });
      });
    });
  });

  app.delete("/api/cms/profile/delete", isAuthenticated, (req, res) => {
    db.profile.findOne({where: {id: req.query.id}}).then(row => {
      db.profile.update({ordering: sequelize.literal("ordering -1")}, {where: {ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.profile.destroy({where: {id: req.query.id}}).then(() => {
          db.profile.findAll(profileReqTreeOnly).then(profiles => {
            profiles = sortProfileTree(profiles);
            res.json(profiles).end();
          });
        });
      });
    });
  });

  app.delete("/api/cms/story/delete", isAuthenticated, (req, res) => {
    db.story.findOne({where: {id: req.query.id}}).then(row => {
      db.story.update({ordering: sequelize.literal("ordering -1")}, {where: {ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.story.destroy({where: {id: req.query.id}}).then(() => {
          db.story.findAll(storyReqTreeOnly).then(stories => {
            stories = sortStoryTree(stories);
            res.json(stories).end();
          });
        });
      });
    });
  });

  app.delete("/api/cms/formatter/delete", isAuthenticated, (req, res) => {
    db.formatter.destroy({where: {id: req.query.id}}).then(() => {
      db.formatter.findAll({attributes: ["id", "name", "description"]}).then(rows => {
        res.json(rows).end();
      });
    });
  });

  app.delete("/api/cms/section/delete", isAuthenticated, (req, res) => {
    db.section.findOne({where: {id: req.query.id}}).then(row => {
      db.section.update({ordering: sequelize.literal("ordering -1")}, {where: {profile_id: row.profile_id, ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.section.destroy({where: {id: req.query.id}}).then(() => {
          db.section.findAll({
            where: {profile_id: row.profile_id},
            attributes: ["id", "title", "slug", "ordering", "profile_id"],
            order: [["ordering", "ASC"]],
            include: [
              {association: "topics", attributes: ["id", "title", "slug", "ordering", "section_id"]}
            ]
          }).then(rows => {
            res.json(rows).end();
          });
        });
      });
    });
  });

  app.delete("/api/cms/topic/delete", isAuthenticated, (req, res) => {
    db.topic.findOne({where: {id: req.query.id}}).then(row => {
      db.topic.update({ordering: sequelize.literal("ordering -1")}, {where: {section_id: row.section_id, ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.topic.destroy({where: {id: req.query.id}}).then(() => {
          db.topic.findAll({where: {section_id: row.section_id}, attributes: ["id", "title", "slug", "ordering", "section_id", "type"], order: [["ordering", "ASC"]]}).then(rows => {
            res.json(rows).end();
          });
        });
      });
    });
  });

  app.delete("/api/cms/storytopic/delete", isAuthenticated, (req, res) => {
    db.storytopic.findOne({where: {id: req.query.id}}).then(row => {
      db.storytopic.update({ordering: sequelize.literal("ordering -1")}, {where: {story_id: row.story_id, ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.storytopic.destroy({where: {id: req.query.id}}).then(() => {
          db.storytopic.findAll({where: {story_id: row.story_id}, attributes: ["id", "title", "slug", "ordering", "story_id", "type"], order: [["ordering", "ASC"]]}).then(rows => {
            res.json(rows).end();
          });
        });
      });
    });
  });

  app.delete("/api/cms/selector/delete", isAuthenticated, (req, res) => {
    db.selector.findOne({where: {id: req.query.id}}).then(row => {
      db.selector.update({ordering: sequelize.literal("ordering -1")}, {where: {topic_id: row.topic_id, ordering: {[Op.gt]: row.ordering}}}).then(() => {
        db.selector.destroy({where: {id: req.query.id}}).then(() => {
          db.selector.findAll({where: {topic_id: row.topic_id}, order: [["ordering", "ASC"]]}).then(rows => {
            res.json(rows).end();
          });
        });
      });
    });
  });

};
